<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>vee-type-safe</title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="assets/js/search.js" data-base=".">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="index.html" class="title">vee-type-safe</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-externals" checked />
							<label class="tsd-widget" for="tsd-filter-externals">Externals</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="globals.html">Globals</a>
				</li>
			</ul>
			<h1> vee-type-safe</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<div class="tsd-panel tsd-typography">
				<h1 id="vee-type-safe">vee-type-safe</h1>
				<p><a href="https://badge.fury.io/js/vee-type-safe"><img src="https://badge.fury.io/js/vee-type-safe.svg" alt="npm version"></a>
				<a href="https://www.typescriptlang.org/"><img src="https://img.shields.io/badge/%3C%2F%3E-TypeScript-%230074c1.svg" alt="TypeScript"></a></p>
				<p>This is a simple TypeScript type checking utility library.
				Requires Typescript version <code>&gt;= 3.2</code>.</p>
				<h2 id="view-detailed-api-documentation-generated-by-typedoc"><strong><a href="https://veetaha.github.io/vee-type-safe/docs/">View detailed API documentation</a> generated by <a href="https://github.com/TypeStrong/typedoc">TypeDoc</a></strong></h2>
				<h2 id="quick-api-glance">Quick API glance</h2>
				<h3 id="mismatch-suspect-typedescr-">mismatch(suspect, typeDescr)</h3>
				<p>Returns a <code>MismatchInfo</code> object (description is bellow) that stores an information
					about type incompatability for given <code>typeDescr</code>, e.g. why and where <code>suspect</code>&#39;s invalid property is.
					This is a powerful tool to generate useful error messages while validating value shape type.
				<em>Note:</em> this function doesn&#39;t allow <code>suspect</code> to have properties not listed in <code>typeDescr</code> which differentiates it from <code>duckMismatch()</code> (see bellow).</p>
				<pre><code class="language-typescript">    <span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> Vts <span class="hljs-keyword">from</span> <span class="hljs-string">'vee-type-safe'</span>;
    <span class="hljs-keyword">const</span> untrustedJson = <span class="hljs-comment">/* ... */</span>;
    <span class="hljs-keyword">const</span> ExpectedJsonTD: Vts.TypeDescription = <span class="hljs-comment">/* ... */</span>;
    <span class="hljs-keyword">const</span> dbDocument = <span class="hljs-comment">/* ... */</span>;

    <span class="hljs-keyword">const</span> mismatchInfo = Vts.mismatch(untrustedJson, ExpectedJsonTD);
    <span class="hljs-keyword">if</span> (mismatchInfo) {
        <span class="hljs-built_in">console</span>.log(
            mismatchInfo.path,
            mismatchInfo.actualValue,
            mismatchInfo.expectedTd
        );
        <span class="hljs-comment">// logs human readable path to invalid property</span>
        <span class="hljs-built_in">console</span>.log(mismatchInfo.pathString());

        <span class="hljs-comment">// mismatchInfo.toErrorString() generates human readable error message</span>
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Vts.TypeMismatchError(mismatchInfo);
    }
    <span class="hljs-comment">// now you may safely assign untrustedJson to dbDocument:</span>
    dbDocument = <span class="hljs-built_in">Object</span>.assign(dbDocument, untrustedJson);</code></pre>
				<h3 id="duckmismatch-suspect-typedescr-"><code>duckMismatch(suspect, typeDescr)</code></h3>
				<p>Works the same way as <code>mismatch(suspect, typeDescr)</code> but allows <code>suspect</code> object with excess properties to pass the match.</p>
				<pre><code class="language-typescript">    <span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> Vts <span class="hljs-keyword">from</span> <span class="hljs-string">'vee-type-safe'</span>;

    Vts.duckMismatch(
        { name: <span class="hljs-string">'Ihor'</span>, somePropertyIDontCareAbout: <span class="hljs-number">42</span> },
        { name: <span class="hljs-string">'string'</span> }
    ); <span class="hljs-comment">// returns null as suspect is allowed to have excess properties</span>

    <span class="hljs-keyword">const</span> untrustedJson = {
        client: <span class="hljs-string">'John Doe'</span>,
        walletNumber: <span class="hljs-literal">null</span>,
    };
    <span class="hljs-keyword">const</span> ExpectedJsonTD: Vts.TypeDescriptionOf&lt;<span class="hljs-keyword">typeof</span> untrustedJson&gt; = {
        client: <span class="hljs-string">'string'</span>,
        walletNumber: <span class="hljs-regexp">/\d{16}/</span> <span class="hljs-comment">// implies a string of the given format</span>
    };

    <span class="hljs-keyword">const</span> mismatchInfo = Vts.duckMismatch(untrustedJson, ExpectedJsonTD);
    <span class="hljs-keyword">if</span> (mismatchInfo) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Vts.TypeMismatchError(mismatchInfo);
    }
    <span class="hljs-comment">// process client</span></code></pre>
				<h2 id="predefined-typedescriptions">Predefined TypeDescriptions</h2>
				<p>There are factory functions that return <code>TypeDescription</code>s (those are often <code>TypePredicate</code>s) or already defined <code>TypePredicates</code>, that you should use as type descriptions when calling <code>mismatch(suspect, typeDescr)</code>.
				<code>TypePredicate</code> is a function of type:</p>
				<p><code>(suspect: unknown) =&gt; boolean</code></p>
				<h3 id="isnumberwithinrange-min-max-"><code>isNumberWithinRange(min, max)</code></h3>
				<p> Returns a predicate that returns <em>true</em> if its argument is a number within the range [<code>min</code>, <code>max</code>] or [<code>max</code>, <code>min</code>] if <code>min &gt; max</code>.</p>
				<pre><code class="language-typescript"> <span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> Vts <span class="hljs-keyword">from</span> <span class="hljs-string">'vee-type-safe'</span>;

 Vts.conforms(
 {
     num: <span class="hljs-number">32</span>
 },
 {
     num: Vts.isNumberWithinRange(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>)
 }); <span class="hljs-comment">// false</span></code></pre>
				<h3 id="isintegerwithinrange-min-max-"><code>isIntegerWithinRange(min, max)</code></h3>
				<p> The same as <code>isNumberWithinRange(min, max)</code>, but its returned predicate returns <em>false</em> if forwarded argument is not an integer.</p>
				<h3 id="optional-typedescr-typedescription-"><code>optional(typeDescr: TypeDescription)</code></h3>
				<p>Retuns <code>Set&lt;TypeDescription&gt;([&#39;undefined&#39;, typeDescr]))</code></p>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> Vts <span class="hljs-keyword">from</span> <span class="hljs-string">'vee-type-safe'</span>;
Vts.conforms(
{
    prop: <span class="hljs-string">'str'</span>
},{
    prop: Vts.optional(<span class="hljs-string">'number'</span>)
}) 
<span class="hljs-comment">// return false because the property is not undefined, </span>
<span class="hljs-comment">// but doesn't conform to 'number' type</span>
Vts.conforms(
{
    prop: <span class="hljs-number">-23</span>
},{
    prop: Vts.optional(Vts.isNegativeInteger)
});
<span class="hljs-comment">// returns true because the property is not undefined</span>
<span class="hljs-comment">// and conforms to isNegativeInteger restriction</span></code></pre>
				<h3 id="self-explanatory-functions">Self explanatory functions</h3>
				<p>All these functions take <code>unknown</code> type argument and return <code>suspect is number</code>, which is useful as a type guard or when using as a type description.</p>
				<ul>
					<li><code>isInteger(suspect)</code></li>
					<li><code>isPositiveInteger(suspect)</code></li>
					<li><code>isNegativeInteger(suspect)</code></li>
					<li><code>isPositiveNumber(suspect)</code></li>
					<li><code>isNegativeNumber(suspect)</code></li>
					<li><code>isZeroOrPositiveInteger(suspect)</code></li>
					<li><code>isZeroOrNegativeInteger(suspect)</code></li>
					<li><code>isZeroOrPositiveNumber(suspect)</code></li>
					<li><code>isZeroOrNegativeNumber(suspect)</code></li>
					<li>...<pre><code class="language-typescript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> Vts <span class="hljs-keyword">from</span> <span class="hljs-string">'vee-type-safe'</span>;
Vts.conforms(
{
  id: <span class="hljs-number">2</span>,
  volume: <span class="hljs-number">22.5</span>
},
{
  id:    Vts.isPositiveInteger,
  money: Vts.isZeroOrPositiveNumber
}); <span class="hljs-comment">// true</span></code></pre>
					</li>
				</ul>
				<h3 id="isoneoft-possiblevalues-t-"><code>isOneOf&lt;T&gt;(possibleValues: T[])</code></h3>
				<p>  Returns a predicate that accepts a suspect of <code>any</code> type and matches it to
					one of the provided possible values by
				<code>possibleValues.includes(suspect)</code>. <strong>Don&#39;t confuse it with <code>new Set(possibleValues)</code></strong> when forwarding as a type description to <code>conforms()</code> function, because <code>possibleValues</code> are not TDs, but values to match with.</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> Vts <span class="hljs-keyword">from</span> <span class="hljs-string">'vee-type-safe'</span>;

Vts.conforms(<span class="hljs-number">2</span>, Vts.isOneOf([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])); <span class="hljs-comment">// true</span>
Vts.conforms(<span class="hljs-number">2</span>,     <span class="hljs-keyword">new</span> Set([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])); <span class="hljs-comment">// compile error</span>
<span class="hljs-comment">// Set&lt;numbers&gt; is not a Set&lt;TypeDescritpion&gt;</span></code></pre>
				<h2 id="convenient-type-definitions">Convenient type definitions</h2>
				<h3 id="interface-basicobjectt"><code>interface BasicObject&lt;T&gt;</code></h3>
				<p>A shorthand for <code>{ [key: string]: T; }</code> type.</p>
				<h3 id="interface-basicfunctortargs-tretval-tprops-"><code>interface BasicFunctor</code>&lt;TArgs, TRetval, TProps&gt;`</h3>
				<p>This interface implies a callable <code>BasicObject&lt;TProps&gt;</code>, where
				<code>TArgs</code> is a tuple of argument types, <code>TRetval</code> is the return type of this function.</p>
				<h3 id="type-primitivetype"><code>type PrimitiveType</code></h3>
				<p>A union of all primitive types (<code>null</code> is treated as a primitive type).</p>
				<h3 id="type-basictypename"><code>type BasicTypeName</code></h3>
				<p>A union type of string literals which are in <code>typeof</code> operator domain definition (<code>&#39;string&#39; | &#39;boolean&#39; | &#39;object&#39; ...</code>).</p>
				<h2 id="vee-type-safe-express-beta-">vee-type-safe/express (BETA)</h2>
				<p>This is a library for <em>ExpressJS</em> routing middleware functions.</p>
				<h3 id="ensuretypematch-getrequestproperty-typedescr-makeerror-"><code>ensureTypeMatch(getRequestProperty, typeDescr, makeError?)</code></h3>
				<p>Returns <code>express.Handler</code> that exactly matches the value returned by <code>getRequestProperty(req)</code> to <code>typeDescr</code> and if it fails, calls <code>next(makeError(failedTypeInfo))</code>.
				Thus you can be sure that the property of <code>express.Request</code> object was type checked before using it in your middleware.</p>
				<p>Does type matching via core library <code>mismatch()</code> function.</p>
				<ul>
					<li><code>getRequestProperty: (req: express.Request) =&gt; unknown</code> - this function must return a suspect to match to <code>typeDescr</code>, based on the given <code>req</code> argument.</li>
					<li><code>typeDescr</code> - type description that the value returned by <code>getRequestProperty(req)</code> must match to</li>
					<li><code>makeError?: (failInfo: MismatchInfo) =&gt; unknown</code> - it is an optional function which makes a custom error to forward to <code>next()</code>, by default this function retuns <code>BadTypeStatusError</code></li>
				</ul>
				<p><code>BadTypeStatusError</code> is an instance of <code>TypeMismatchError</code> that has a <code>status: number</code> property, which is http <em>BAD_REQUEST</em> by default.</p>
				<pre><code class="language-typescript">    <span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> express <span class="hljs-keyword">from</span> <span class="hljs-string">'express'</span>;
    <span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> VtsEx   <span class="hljs-keyword">from</span> <span class="hljs-string">'vee-type-safe/express'</span>
    <span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> Vts     <span class="hljs-keyword">from</span> <span class="hljs-string">'vee-type-safe'</span>;
    <span class="hljs-keyword">const</span> router = express.Router();
    <span class="hljs-keyword">interface</span> MessagesPostRequest {
        filters: <span class="hljs-built_in">string</span>[];
        limit: <span class="hljs-built_in">number</span>;
    }

    router.post(<span class="hljs-string">'api/v1/messages'</span>,
        VtsEx.matchType(
            VtsEx.ReqBody, <span class="hljs-comment">// or req =&gt; req.body (your custom obtaining logic here)</span>
            {
                filters: [<span class="hljs-string">'string'</span>],
                limit:   Vts.isPositiveInteger
            },
            <span class="hljs-function"><span class="hljs-params">mmInfo</span> =&gt;</span> <span class="hljs-keyword">new</span> MyCustomError(mmInfo.path, mmInfo.actualValue)
        ),
            <span class="hljs-comment">// replaces standard express.Request.body type with MessagesPostRequest</span>
        (req: VtsEx.ReqBody&lt;MessagesPostRequest&gt;, res, next) =&gt; {
            <span class="hljs-comment">/* your middleware, where you can trust to req.body */</span>
            <span class="hljs-comment">// req.body has MessagesPostRequest type here</span>
            <span class="hljs-keyword">const</span> filters = req.body.filters.join();
            <span class="hljs-comment">// ...</span>
        }
    );</code></pre>
				<p>There is a list of handy functions to specify as <code>getRequestProperty</code> argument:</p>
				<ul>
					<li><code>ReqBody(req)    =&gt; req.body</code></li>
					<li><code>ReqParams(req)  =&gt; req.params</code></li>
					<li><code>ReqQuery(req)   =&gt; req.query</code></li>
					<li><code>ReqCookies(req) =&gt; req.cookies</code></li>
					<li><code>ReqHeaders(req) =&gt; req.headers</code><pre><code class="language-typescript">  <span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> VtsEx <span class="hljs-keyword">from</span> <span class="hljs-string">'vee-type-safe/express'</span>;
  <span class="hljs-comment">/* ... */</span>
  router.get(<span class="hljs-string">'api/v1/users/'</span>,
      VtsEx.matchType(VtsEx.ReqQuery, { title: <span class="hljs-string">'string'</span> }),
      <span class="hljs-function">(<span class="hljs-params">req: VtsEx.ReqQuery&lt;{title: <span class="hljs-built_in">string</span>}&gt;, res, next</span>) =&gt;</span> {
          <span class="hljs-keyword">const</span> title: <span class="hljs-built_in">string</span> = req.query.title; <span class="hljs-comment">// now you are sure</span>
          <span class="hljs-comment">/* ... */</span>
      }
  );</code></pre>
					</li>
				</ul>
			</div>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="globals.html"><em>Globals</em></a>
					</li>
					<li class="label tsd-is-external">
						<span>Internals</span>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_index_.html">"index"</a>
					</li>
					<li class="label tsd-is-external">
						<span>Externals</span>
					</li>
					<li class=" tsd-kind-external-module tsd-is-external">
						<a href="modules/_type_descriptions_.html">"type-<wbr>descriptions"</a>
					</li>
					<li class=" tsd-kind-external-module tsd-is-external">
						<a href="modules/_types_.html">"types"</a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-module"><span class="tsd-kind-icon">Module</span></li>
				<li class="tsd-kind-object-literal"><span class="tsd-kind-icon">Object literal</span></li>
				<li class="tsd-kind-variable"><span class="tsd-kind-icon">Variable</span></li>
				<li class="tsd-kind-function"><span class="tsd-kind-icon">Function</span></li>
				<li class="tsd-kind-function tsd-has-type-parameter"><span class="tsd-kind-icon">Function with type parameter</span></li>
				<li class="tsd-kind-index-signature"><span class="tsd-kind-icon">Index signature</span></li>
				<li class="tsd-kind-type-alias"><span class="tsd-kind-icon">Type alias</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-enum"><span class="tsd-kind-icon">Enumeration</span></li>
				<li class="tsd-kind-enum-member"><span class="tsd-kind-icon">Enumeration member</span></li>
				<li class="tsd-kind-property tsd-parent-kind-enum"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-enum"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-interface"><span class="tsd-kind-icon">Interface</span></li>
				<li class="tsd-kind-interface tsd-has-type-parameter"><span class="tsd-kind-icon">Interface with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-interface"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-interface"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-interface"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li>
				<li class="tsd-kind-class tsd-has-type-parameter"><span class="tsd-kind-icon">Class with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class"><span class="tsd-kind-icon">Accessor</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-class"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static property</span></li>
				<li class="tsd-kind-call-signature tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static method</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="http://typedoc.org/" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="assets/js/main.js"></script>
<script>if (location.protocol == 'file:') document.write('<script src="assets/js/search.js"><' + '/script>');</script>
</body>
</html>
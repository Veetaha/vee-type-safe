# vee-type-safe
[![npm version](https://badge.fury.io/js/vee-type-safe.svg)](https://badge.fury.io/js/vee-type-safe)
[![TypeScript](https://img.shields.io/badge/%3C%2F%3E-TypeScript-%230074c1.svg)](https://www.typescriptlang.org/)


This is a simple TypeScript type checking utility library.
Requires Typescript version `>= 3.0`.

## API

## **Beta [API page](https://veetaha.github.io/vee-type-safe/docs/) generated by [TypeDoc](https://github.com/TypeStrong/typedoc)**

## v 2.0

*(Pleese, see v 1.0 API in the first place if you are not familiar with this library)*

### mismatch(suspect, typeDescr)
Returns a `MismatchInfo` object (description is bellow) that stores an information
about type incompatability for given `typeDescr`, e.g. why and where `suspect`'s invalid property is. If `exactlyConforms(suspect, typeDescr)` this function returns *null*.
This is a powerful tool to generate useful error messages while validating value shape type.
*Note:* this function doesn't allow `suspect` to have properties not listed in `typeDescr` which differentiates it from `duckMismatch()` (see bellow).

~~~typescript
    import * as Vts from 'vee-type-safe';
    const untrustedJson = /* ... */;
    const ExpectedJsonTD: Vts.TypeDescription = /* ... */;
    const dbDocument = /* ... */

    const mismatchInfo = Vts.mismatch(untrustedJson, ExpectedJsonTD);
    if (mismatchInfo) {
        console.log(
            mismatchInfo.path,
            mismatchInfo.actualValue,
            mismatchInfo.expectedTd
        );
        // logs human readable path to invalid property
        console.log(mismatchInfo.pathString());

        // mismatchInfo.toErrorString() generates human readable error message
        throw new Vts.TypeMismatchError(mismatchInfo);
    }
    // now you may safely assign untrustedJson to dbDocument:
    dbDocument = Object.assign(dbDocument, untrustedJson);
~~~


### `duckMismatch(suspect, typeDescr)`
Works the same way as `mismatch(suspect, typeDescr)` but allows `suspect` object with excess properties to pass the match.

~~~typescript
    import * as Vts from 'vee-type-safe';

    Vts.duckMismatch(
        { name: 'Ihor', somePropertyIDontCareAbout: 42 },
        { name: 'string' }
    ); // returns null as suspect is allowed to have excess properties

    const untrustedJson = {
        client: 'John Doe',
        walletNumber: null,
    };
    const ExpectedJsonTD: Vts.TypeDescriptionOf<typeof untrustedJson> = {
        client: 'string',
        walletNumber: /\d{16}/ // implies a string of the given format
    };

    const mismatchInfo = Vts.duckMismatch(untrustedJson, ExpectedJsonTD);
    if (mismatchInfo) {
        throw new Vts.TypeMismatchError(mismatchInfo);
    }
    // process client
~~~




### `match(suspect: unknown, typeDescr: TypeDescription)`   **DEPRECATED**: use `duckMismatch()` instead

### `exactlyMatch(suspect: unknown, typeDescr: TypeDescription)` **DEPRECATED**: use `mismatch()` instead

### `ensureMatch(suspect: unknown, typeDescr: TypeDescription)`
### `ensureDuckMatch(suspect: unknown, typeDescr: TypeDescription)`

**Previously**: `tryExactlyMatch()` and `tryMatch()`

These functions return nothing. They throw `TypeMismatchError` if their `suspect` failed to match to the given `typeDescr`.

`TypeMismatchError` is an instance of `Error` with `typeMismatch: MismatchInfo` property.


### `class MatchInfo` **DEPRECATED**: use `class MismatchInfo` instead

### `class MismatchInfo`

Represents the result of running `mismatch(suspect, typeDescr)`
or `duckMismatch(suspect, typeDescr)` functions.
It contains an information about why `suspect` doesn't conform to the given `typeDescr`: the actual value, expected type description and a property path to unexpected value type.

### properties

* `path: PathArray` - an array of numbers and strings which defines a path to suspect's invalid `actualValue`. E.g. if `suspect.foo.bar[3][5]` failed to match to the `expectedTd`, then `path` would be `[ 'foo', 'bar', 3, 5 ]`

* `expectedTd: TypeDescription` - `TypeDescription` that `actualValue` was expected to conform to.

* `actualValue: unknown` - value which failed to conform to the `expectedTd`.

### methods

### `pathString()`

Returns `path` converted to a human readable JavaScript property access notation string if match was failed. Returned string begins with the `'root'` as the root object to access the properties.
~~~typescript
import * as Vts from 'vee-type-safe';
const mismatchInfo = Vts.mismatch(
    {
        foo: {
            bar: {
                'twenty two': [
                    { prop: 'str' }, 
                    { prop: -23 }
                ]
            }
        }
    },
    { foo: { bar: { 'twenty two': [ { prop: 'string' } ] } } }
);

mismatchInfo.pathString() === `root.foo.bar['twenty two'][1].prop`
~~~

### `toErrorString()`

Returns a string of form:

*value (`JSON.stringify(actualValue)`) at path '`pathString()`' doesn't \[exactly] conform to the given type description (`stringifyTd(expectedTd)`)*

If `JSON.stringify(actualValue)` throws an error, it is excluded from the returned string.

## vee-type-safe/express
This is a library for *ExpressJS* routing middleware functions.

### `ensureTypeMatch(getRequestProperty, typeDescr, makeError?)`

Returns `express.Handler` that exactly matches the value returned by `getRequestProperty(req)` to `typeDescr` and if it fails, calls `next(makeError(failedTypeInfo))`.
Thus you can be sure that the property of `express.Request` object was type checked before using it in your middleware.

Does type matching via core library `mismatch()` function.

* `getRequestProperty: (req: express.Request) => unknown` - this function must return a suspect to match to `typeDescr`, based on the given `req` argument.
* `typeDescr` - type description that the value returned by `getRequestProperty(req)` must match to
* `makeError?: (failInfo: MismatchInfo) => unknown` - it is an optional function which makes a custom error to forward to `next()`, by default this function retuns `BadTypeStatusError`

`BadTypeStatusError` is an instance of `TypeMismatchError` that has a `status: number` property, which is http *BAD_REQUEST* by default.

~~~typescript
    import * as express from 'express';
    import * as VtsEx   from 'vee-type-safe/express'
    import * as Vts     from 'vee-type-safe';
    const router = express.Router();
    interface MessagesPostRequest {
        filters: string[];
        limit: number;
    }

    router.post('api/v1/messages',
        VtsEx.matchType(
            VtsEx.ReqBody, // or req => req.body (your custom obtaining logic here)
            {
                filters: ['string'],
                limit:   Vts.isPositiveInteger
            },
            mmInfo => new MyCustomError(mmInfo.path, mmInfo.actualValue)
        ),
            // replaces standard express.Request.body type with MessagesPostRequest
        (req: VtsEx.ReqBody<MessagesPostRequest>, res, next) => {
            /* your middleware, where you can trust to req.body */
            // req.body has MessagesPostRequest type here
            const filters = req.body.filters.join();
            // ...
        }
    );
~~~

There is a list of handy functions to specify as `getRequestProperty` argument:
* `ReqBody(req)    => req.body`
* `ReqParams(req)  => req.params`
* `ReqQuery(req)   => req.query`
* `ReqCookies(req) => req.cookies`
* `ReqHeaders(req) => req.headers`
~~~typescript
    import * as VtsEx from 'vee-type-safe/express';
    /* ... */
    router.get('api/v1/users/',
        VtsEx.matchType(VtsEx.ReqQuery, { title: 'string' }),
        (req: ReqQuery<{title: string}>, res, next) => {
            const title: string = req.query.title; // now you are sure
            /* ... */
        }
    );
~~~


### `ensureDuckTypeMatch(getRequestProperty, typeDescr, makeError?)`

The same middleware factory as `ensureTypeMatch()`, but does type matching via core library `duckMismatch()` function.



## v 1.0

### `conforms<T>(suspect, typeDescr): suspect is T`
  It is a two in one: runtime type checker and static type guard.   
  Determines whether the specified suspect type satisfies the restriction of the given type
  description (TD). (Seeing example below first may be helpful).
  
  * `T` is a TypeScript type suspect is treated as, if this function returns *true*.
  * `suspect` is a value of `unknown` type to be tested for conformance according to TD.
  
  * `typeDescr` is a value of `TypeDescription` type. 
    * If `isBasicTypeName(typeDescr)`. 
      Returns `typeof suspect === typeDescr`.

    * If it is a `RegExp`, then returns
      `typeof suspect === 'string' && typeDescr.test(suspect)`.

    * If `typeDescr` is a `TypePredicate` function. Returns `Boolean(typeDescr(suspect))`.
    * If `typeDescr instanceof Set<TD>`.
      Returns *true* if suspect conforms to at least one of the given TDs in the `Set`.
    * If `Array.isArray(typeDescr)` returns *false* if `!Array.isArray(suspect)` 
        * If `typeDescr.length === 1`. Returns *true* if each of suspect's items conforms to the given
                   TD at `typeDescr[0]`.
        * If `typeDescr.length > 1`. Returns *true* if `suspect.length === typeDescr.length`
                   and each `suspect[i]` conforms to `typeDescr[i]` type description.
        * If `typeDescr.length === 0`. Returns *true*.
     * If `isBasicObject(typeDescr)`. Returns *true* if `isBasicObject(suspect)` and
                   each `suspect[key]` conforms to `typeDescr[key]`. ([Excess properties in `suspect`
                   do not matter](https://en.wikipedia.org/wiki/Duck_typing)).
     * Else returns *false*.
     
~~~typescript  
import * as Vts from 'vee-type-safe';

Vts.conforms(
{
       prop: 'lala',
       prop2: true,
       obj: {
           obj: [23, false]
       },
       someIDontCareProperty: null // excess properties are ok
},
{
       prop: 'string',
       prop2: 'boolean',
       obj: {
           obj: ['number', 'boolean'] // claims a fixed length tuple
       }
}); // true

Vts.conforms(
{
     arr: ['array', null, 'of any type', 8888 ],
     strArr: ['Pinkie', 'Promise', 'some', 'strings'],
     oneOf: 2,
     custom: 43
}, 
{
     arr: [],                              // claims an array of any type
     strArr: ['string'],                   // claims an array of any length
     oneOf: new Set(['boolean', 'number']),// claims to be one of these types
     custom: isOddNumber                   // custom type predicate function
}); // true

function isOddNumber(suspect: unknown): suspect is number {
    return typeof suspect === 'number' && suspect % 2;
}  

// Type argument:
interface Human {
    name: string;
    id:   number;
}
const HumanTD: Vts.TypeDescriptionOf<Human>  = {
    name: 'string',  // using Vts.TypeDescriptionOf<T> gives you better typing
    id:   'number'
};
function tryUseHuman(maybeHuman: unknown) {
    if (conforms<Human>(maybeHuman, HumanTD)) {
        // maybeHuman is of type Human here
        maybeHuman.name;
        maybeHuman.id;
    }
}
~~~

### `exactlyConforms<T>(suspect, typeDescr): suspect is T`
This function is the same as `conforms()`, but returns *false* for suspect object that has excess properties (those, that are not present in type description object).
~~~typescript
import * as Vts from 'vee-type-safe';
Vts.conforms(23, 'number') === Vts.exactlyConforms(23, 'number');
const suspect = {
    listedInt: 7,
    listedStr: 'readme',
    unlistedProp: ['some', 'excess', 'prop', 'value']
}
const td: TypeDescription = {
    listedInt: isPositiveInteger,
    listedStr: 'string'
}
Vts.conforms(suspect, td) === true;
Vts.exactlyConforms(suspect, td) === false;
~~~




### Factory functions
 (previously were in namespace Factory)
  
Factory functions return `TypePredicate`s to use as type descriptions when calling `conforms(suspect, typeDescr)`.
`TypePredicate` is a function of type:

`(suspect: unknown): boolean`

### `isNumberWithinRange(min, max)`
    
 Returns a predicate that returns *true* if its argument is a number within the range \[`min`, `max`] or \[`max`, `min`] if `min > max`.
 ~~~typescript
 import * as Vts from 'vee-type-safe';
 
 Vts.conforms(
 {
     num: 32
 },
 {
     num: Vts.isNumberWithinRange(0, 5)
 }); // false
 ~~~

### `isIntegerWithinRange(min, max)`
 The same as `isNumberWithinRange(min, max)`, but its returned predicate returns *false* if forwarded argument is not an integer.
 
### `optional(typeDescr: TypeDescription)`
Retuns `TypePredicate` which retuns `typeof suspect === 'undefined' || conforms(typeDescr)`, which you may use as a type description for optional object properties. This predicate is effectively the same as calling `conforms(suspect, new Set<TypeDescription>([typeDescr, 'undefined']));`
~~~typescript
import * as Vts from 'vee-type-safe';
Vts.conforms(
{
    prop: 'str'
},{
    prop: Vts.optional('number')
}) 
// return false because the property is not undefined, 
// but doesn't conform to 'number' type
Vts.conforms(
{
    prop: -23
},{
    prop: Vts.optional(Vts.isNegativeInteger)
});
// returns true because the property is not undefined
// and conforms to isNegativeInteger restriction
~~~
 
 
### `isOneOf<T>(possibleValues: T[])`
  Returns a predicate that accepts a suspect of `any` type and matches it to
    one of the provided possible values by
    `possibleValues.includes(suspect)`. **Don't confuse it with `new Set(possibleValues)`** when forwarding as a type description to `conforms()` function, because `possibleValues` are not TDs, but values to match with.
~~~typescript
import * as Vts from 'vee-type-safe';

Vts.conforms(2, Vts.isOneOf([0, 1, 2, 3])); // true
Vts.conforms(2,     new Set([0, 1, 2, 3])); // compile error
// Set<numbers> is not a Set<TypeDescritpion>
~~~ 

### `makeTdWithOptionalProps(srcTypeDescr: TypeDescrObjMap)`
Returns a new `TypeDescrObjMap` (which is assignable to `TypeDescription`) object that is composed of `srcTypeDescr` properties wrapped as
 
 `result[propName] = optional(srcTypeDescr[propName])`
 
 for each `propName` in `srcTypeDescr` own property names.
 
 
### Type definitions

### `interface BasicObject<T>`
A shorthand for `{ [key: string]: T; }` type.

### `interface BasicFunctor`<TArgs, TRetval, TProps>`
This interface implies a callable `BasicObject<TProps>`, where 
`TArgs` is a tuple of argument types, `TRetval` is the return type of this function.

### `type PrimitiveType`
A set of all primitive types (`null` is treated as a primitive type).

### `type BasicTypeName`
A set of strings which are in `typeof` operator domain (`'string' | 'boolean' | 'object' ...`).

### `isBasicObject(suspect)`
Returns *true* if suspect is truthy (e.g. not `null`) and `typeof suspect === 'object'` or `'function'`.

### `reinterpret<T>(value)`
C++ style operator, a syntactic sugar for writing
casts like `value as any as T` when a simple `value as T` cast cannot be performed. Use it with caution!


### `typeAssert<T>(value): value is T`
TypeScript type guard that always returns *true*.
You may use it in an if statement to assert the proper type in the following code execution path.
~~~typescript
    import * as Vts from 'vee-type-safe';
    const enum SomeEnum {
        A = 0, B, C
    }
    const numb: number = 2;
    if (!Vts.typeAssert<SomeEnum>(numb)) { return; }
    numb; // deduced type is SomeEnum
    
~~~
### `assertNever(suspect: never)`
This function is no-op, but it is useful to check whether you have
 handled all the cases and some code path is unreachable. TypeScript compiler will issue an error if you forward a value not of [`never` type](https://www.typescriptlang.org/docs/handbook/basic-types.html#never) to this function.
~~~typescript
import * as Vts from 'vee-type-safe';
const enum Enum {
    A, B, C
}
function fn(en: Enum) {
    switch (en) {
        case Enum.A: { /***/ return; }
        case Enum.B: { /***/ return; }
        default: {
            Vts.assertNever(en); // compile Error, en is of type Enum.C
        }
    }
}
//-------------
const num = 23;
if (typeof num !== 'number'){
    Vts.assertNever(num); // no error, this code is unreachable
    // num is of type never here
}
~~~ 


### `isBasicTypeName(suspect): suspect is BasicTypeName`
Returns *true* if suspect is a string that is inside a set of `BasicTypeName` type set.
~~~typescript
import * as Vts from 'vee-type-safe';

Vts.isBasicTypeName('null');    // false
Vts.isBasicTypeName(' number'); // false
Vts.isBasicTypeName('number');  // true
~~~

### `isIsoDateString(suspect: unknown)`
Checks that suspect is a string and it conforms to ISO 8601 format.
Internally uses ['is-iso-date'](https://www.npmjs.com/package/is-iso-date) npm package. Returns `suspect is string` as a type guard.
Example taken from [here](https://www.npmjs.com/package/is-iso-date):
~~~typescript
import * as Vts  from 'vee-type-safe';
Vts.isIsoDateString(8888); // false
Vts.isIsoDateString({
   iso: '2015-02-21T00:52:43.822Z'
}); // false
Vts.isIsoDateString( '2015-02-21T00:52:43.822Z' ); // true
Vts.isIsoDateString( '2015-02-21T00:52:43.822' );  // false
Vts.isIsoDateString( '2015-02-21T00:52:43Z' );     // true
Vts.isIsoDateString( '2015-02-21T00:52:43' );      // false
Vts.isIsoDateString( '2015-02-21T00:52Z' );        // true
Vts.isIsoDateString( '2015-02-21T00:52' );         // false
Vts.isIsoDateString( '2015-02-21T00Z' );           // false
const someObj = {
    date: '2015-02-21T00:52Z'
};
Vts.conforms(someObj, {
    date: Vts.isIsoDateString
}); // true
~~~

### Self explanatory functions
All these functions take `unknown` type argument and return `suspect is number`, which is useful as a type guard or when using as a type description.

* `isInteger(suspect)`
* `isPositiveInteger(suspect)`
* `isNegativeInteger(suspect)`
* `isPositiveNumber(suspect)`
* `isNegativeNumber(suspect)`
* `isZeroOrPositiveInteger(suspect)`
* `isZeroOrNegativeInteger(suspect)`
* `isZeroOrPositiveNumber(suspect)`
* `isZeroOrNegativeNumber(suspect)`
~~~typescript
import * as Vts from 'vee-type-safe';
Vts.conforms(
{
    id: 2,
    volume: 22.5
},
{
    id:    Vts.isPositiveInteger,
    money: Vts.isZeroOrPositiveNumber
}); // true
~~~


### `defaultIfNotConforms<T>(typeDescr, suspect, defaultVal): T`
Checks whether `suspect` conforms to the given type description (`typeDescr`) and returns it if `conforms(suspect, typeDescr)`, otherwise returns `defaultVal`.
* `typeDescr: TypeDescription` - TD suspect may conform to. `defaultVal` **must** conform to this TD
* `suspect: unknown` value to provide default for
* `defaultVal: T` value that conforms to `typeDescr` that is returned by this function if `!conforms(suspect, typeDescr)`
~~~typescript
import * as Vts from 'vee-type-safe';

const id = Vts.defaultIfNotConforms(Vts.isPositiveInteger, parseInt('-1'), 0);
// id === 0;
const id2 = Vts.defaultIfNotConforms(Vts.isPositiveInteger, parseInt('444'), 0);
// id2 === 444
~~~
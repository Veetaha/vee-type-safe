# vee-type-safe
[![npm version](https://badge.fury.io/js/vee-type-safe.svg)](https://badge.fury.io/js/vee-type-safe)
[![TypeScript](https://img.shields.io/badge/%3C%2F%3E-TypeScript-%230074c1.svg)](https://www.typescriptlang.org/)


This is a simple TypeScript type checking utility library.
Requires Typescript version `>= 3.2`.


## **[View detailed API documentation](https://veetaha.github.io/vee-type-safe/docs/) generated by [TypeDoc](https://github.com/TypeStrong/typedoc)**

## Quick API glance

### mismatch(suspect, typeDescr)
Returns a `MismatchInfo` object (description is bellow) that stores an information
about type incompatability for given `typeDescr`, e.g. why and where `suspect`'s invalid property is.
This is a powerful tool to generate useful error messages while validating value shape type.
*Note:* this function doesn't allow `suspect` to have properties not listed in `typeDescr` which differentiates it from `duckMismatch()` (see bellow).

~~~typescript
    import * as Vts from 'vee-type-safe';
    const untrustedJson = /* ... */;
    const ExpectedJsonTD: Vts.TypeDescription = /* ... */;
    const dbDocument = /* ... */;

    const mismatchInfo = Vts.mismatch(untrustedJson, ExpectedJsonTD);
    if (mismatchInfo) {
        console.log(
            mismatchInfo.path,
            mismatchInfo.actualValue,
            mismatchInfo.expectedTd
        );
        // logs human readable path to invalid property
        console.log(mismatchInfo.pathString());

        // mismatchInfo.toErrorString() generates human readable error message
        throw new Vts.TypeMismatchError(mismatchInfo);
    }
    // now you may safely assign untrustedJson to dbDocument:
    dbDocument = Object.assign(dbDocument, untrustedJson);
~~~


### `duckMismatch(suspect, typeDescr)`
Works the same way as `mismatch(suspect, typeDescr)` but allows `suspect` object with excess properties to pass the match.

~~~typescript
    import * as Vts from 'vee-type-safe';

    Vts.duckMismatch(
        { name: 'Ihor', somePropertyIDontCareAbout: 42 },
        { name: 'string' }
    ); // returns null as suspect is allowed to have excess properties

    const untrustedJson = {
        client: 'John Doe',
        walletNumber: null,
    };
    const ExpectedJsonTD: Vts.TypeDescriptionOf<typeof untrustedJson> = {
        client: 'string',
        walletNumber: /\d{16}/ // implies a string of the given format
    };

    const mismatchInfo = Vts.duckMismatch(untrustedJson, ExpectedJsonTD);
    if (mismatchInfo) {
        throw new Vts.TypeMismatchError(mismatchInfo);
    }
    // process client
~~~

## Predefined TypeDescriptions
  
There are factory functions that return `TypeDescription`s (those are often `TypePredicate`s) or already defined `TypePredicates`, that you should use as type descriptions when calling `mismatch(suspect, typeDescr)`.
`TypePredicate` is a function of type:

`(suspect: unknown) => boolean`

### `isNumberWithinRange(min, max)`
    
 Returns a predicate that returns *true* if its argument is a number within the range \[`min`, `max`] or \[`max`, `min`] if `min > max`.
 ~~~typescript
 import * as Vts from 'vee-type-safe';
 
 Vts.conforms(
 {
     num: 32
 },
 {
     num: Vts.isNumberWithinRange(0, 5)
 }); // false
 ~~~

### `isIntegerWithinRange(min, max)`
 The same as `isNumberWithinRange(min, max)`, but its returned predicate returns *false* if forwarded argument is not an integer.
 
### `optional(typeDescr: TypeDescription)`
Retuns `Set<TypeDescription>(['undefined', typeDescr]))`
~~~typescript
import * as Vts from 'vee-type-safe';
Vts.conforms(
{
    prop: 'str'
},{
    prop: Vts.optional('number')
}) 
// return false because the property is not undefined, 
// but doesn't conform to 'number' type
Vts.conforms(
{
    prop: -23
},{
    prop: Vts.optional(Vts.isNegativeInteger)
});
// returns true because the property is not undefined
// and conforms to isNegativeInteger restriction
~~~
 
### Self explanatory functions
All these functions take `unknown` type argument and return `suspect is number`, which is useful as a type guard or when using as a type description.

* `isInteger(suspect)`
* `isPositiveInteger(suspect)`
* `isNegativeInteger(suspect)`
* `isPositiveNumber(suspect)`
* `isNegativeNumber(suspect)`
* `isZeroOrPositiveInteger(suspect)`
* `isZeroOrNegativeInteger(suspect)`
* `isZeroOrPositiveNumber(suspect)`
* `isZeroOrNegativeNumber(suspect)`
* ...
~~~typescript
import * as Vts from 'vee-type-safe';
Vts.conforms(
{
    id: 2,
    volume: 22.5
},
{
    id:    Vts.isPositiveInteger,
    money: Vts.isZeroOrPositiveNumber
}); // true
~~~

 
### `isOneOf<T>(possibleValues: T[])`
  Returns a predicate that accepts a suspect of `any` type and matches it to
    one of the provided possible values by
    `possibleValues.includes(suspect)`. **Don't confuse it with `new Set(possibleValues)`** when forwarding as a type description to `conforms()` function, because `possibleValues` are not TDs, but values to match with.
~~~typescript
import * as Vts from 'vee-type-safe';

Vts.conforms(2, Vts.isOneOf([0, 1, 2, 3])); // true
Vts.conforms(2,     new Set([0, 1, 2, 3])); // compile error
// Set<numbers> is not a Set<TypeDescritpion>
~~~ 

## Convenient type definitions

### `interface BasicObject<T>`
A shorthand for `{ [key: string]: T; }` type.

### `interface BasicFunctor`<TArgs, TRetval, TProps>`
This interface implies a callable `BasicObject<TProps>`, where 
`TArgs` is a tuple of argument types, `TRetval` is the return type of this function.

### `type PrimitiveType`
A union of all primitive types (`null` is treated as a primitive type).

### `type BasicTypeName`
A union type of string literals which are in `typeof` operator domain definition (`'string' | 'boolean' | 'object' ...`).


## vee-type-safe/express (BETA)
This is a library for *ExpressJS* routing middleware functions.

### `ensureTypeMatch(getRequestProperty, typeDescr, makeError?)`

Returns `express.Handler` that exactly matches the value returned by `getRequestProperty(req)` to `typeDescr` and if it fails, calls `next(makeError(failedTypeInfo))`.
Thus you can be sure that the property of `express.Request` object was type checked before using it in your middleware.

Does type matching via core library `mismatch()` function.

* `getRequestProperty: (req: express.Request) => unknown` - this function must return a suspect to match to `typeDescr`, based on the given `req` argument.
* `typeDescr` - type description that the value returned by `getRequestProperty(req)` must match to
* `makeError?: (failInfo: MismatchInfo) => unknown` - it is an optional function which makes a custom error to forward to `next()`, by default this function retuns `BadTypeStatusError`

`BadTypeStatusError` is an instance of `TypeMismatchError` that has a `status: number` property, which is http *BAD_REQUEST* by default.

~~~typescript
    import * as express from 'express';
    import * as VtsEx   from 'vee-type-safe/express'
    import * as Vts     from 'vee-type-safe';
    const router = express.Router();
    interface MessagesPostRequest {
        filters: string[];
        limit: number;
    }

    router.post('api/v1/messages',
        VtsEx.matchType(
            VtsEx.ReqBody, // or req => req.body (your custom obtaining logic here)
            {
                filters: ['string'],
                limit:   Vts.isPositiveInteger
            },
            mmInfo => new MyCustomError(mmInfo.path, mmInfo.actualValue)
        ),
            // replaces standard express.Request.body type with MessagesPostRequest
        (req: VtsEx.ReqBody<MessagesPostRequest>, res, next) => {
            /* your middleware, where you can trust to req.body */
            // req.body has MessagesPostRequest type here
            const filters = req.body.filters.join();
            // ...
        }
    );
~~~

There is a list of handy functions to specify as `getRequestProperty` argument:
* `ReqBody(req)    => req.body`
* `ReqParams(req)  => req.params`
* `ReqQuery(req)   => req.query`
* `ReqCookies(req) => req.cookies`
* `ReqHeaders(req) => req.headers`
~~~typescript
    import * as VtsEx from 'vee-type-safe/express';
    /* ... */
    router.get('api/v1/users/',
        VtsEx.matchType(VtsEx.ReqQuery, { title: 'string' }),
        (req: VtsEx.ReqQuery<{title: string}>, res, next) => {
            const title: string = req.query.title; // now you are sure
            /* ... */
        }
    );
~~~